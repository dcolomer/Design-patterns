<html><head><title>http://www.javaworld.com/javaworld/jw-06-2002/jw-0628-designpatterns.html</title>
</head>
<base href="http://www.javaworld.com/javaworld/jw-06-2002/jw-0628-designpatterns.html">
<body bgcolor="#FFFFFF">
<font size="1">Sponsored by:</font><BR>
<A HREF="http://ad.doubleclick.net/jump/idg.us.nwf.jw_core/jw_printer;pos=top;sz=728x90;tile=1;ord=1329851697?">
<IMG SRC="http://ad.doubleclick.net/ad/idg.us.nwf.jw_core/jw_printer;pos=top;sz=728x90;tile=1;ord=1329851697?" border=0 height="90" width="728"></A>
<p>
<IMG SRC="http://www.javaworld.com/includes/styles/i/javaworld-logo-wht-bg.gif" WIDTH="173" HEIGHT="57" ALT="From JavaWorld:"><br>
<BR>
<font size="-1">This story appeared on JavaWorld at<BR>
http://www.javaworld.com/javaworld/jw-06-2002/jw-0628-designpatterns.html<P></font>
                                                      <!--startindex-->                           <a id="top" name="top"></a><h1>Take command of your software</h1>                           <H3>The Command pattern benefits both the client and the server</H3>                           <p class="byline">By&nbsp;David Geary,&nbsp;JavaWorld.com,&nbsp;06/28/02</p>                           <!--#include virtual="/includes/community/storytools_bar_top.html"-->                                                      <!-- CONTENT GOES HERE-->                           <!--#set var="pages" value="5" --><!--#include virtual="/cgi-bin/pgnav05.pl?pageof=yes&pages=${pages}&${compare}" --><!--#if expr="${compare} = /^page\=1$/ || ${compare} = /^page\=full/" -->                           <p class="first">If you've been developing software long enough, you might recall a time before object-oriented (OO) development went mainstream                              when software development proved much more difficult than it is today. In those days, developers wrote software using archaic                              <em>function libraries</em> to develop applications entirely from scratch, using low-level functions from those libraries to develop software systems.                              For the fruits of their labors, developers produced software such as Microsoft Windows 3.1, which ever since has been known                              as the poster boy for clunky software that crashed soon after your last reboot.                           </p>                           <p>Today, of course, things have improved considerably. Instead of Windows 3.1, we now have Windows XP, a vast improvement over                              its predecessors, and other software marvels, such as the amazing Mac OS X. Many factors contributed to the increase of software                              productivity and reliability over the years, but the overriding factor has been the widespread adoption of OO design and development,                              which turned the paradigm of developing software from scratch with function libraries completely inside-out. With OO design,                              developers employ application frameworks that provide the majority of an application's code and implement applications by                              plugging reusable components into those frameworks.                           </p>                           <p>In the early days, when application frameworks first appeared, developers faced a major hurdle. Application frameworks must                              issue requests to application-specific objects without knowing anything about those objects or the operations they perform.                              For example, the Swing application framework issues requests to objects when menu items are activated or buttons are pressed.                              Swing can't implement those requests because they are application-specific. So how does an application framework like Swing                              issue requests to objects without knowing anything about the requested operation or the objects themselves? The answer: the                              Command design pattern.                           </p>                           <p>In this article, I discuss the Command pattern, sometimes known as the Action pattern, from two different perspectives. First,                              I show how the Command pattern works in client-side Java with Swing's implementation of the Command pattern for menu items.                              Second, I discuss how the Command pattern works in server-side Java to parameterize HTTP requests with the Apache Struts JSP                              (JavaServer Pages) framework. Along the way, you will learn a bit about Swing, Struts, and the newest kid on the server-side                              Java block, the JSP Standard Tag Library (JSTL).                           </p>                           <p><strong>Note:</strong> You can download this article's example source code from <a href="#resources">Resources</a>.                           </p>                           <h3>The Command pattern</h3>                           <p>In <a href="#resources"><em>Design Patterns</em></a>, the authors define the Command pattern as:                           </p>                           <blockquote>Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests,                              and support undoable operations.                           </blockquote><br><br>                            <p>By implementing commands as objects, the Command pattern lets application frameworks invoke methods of application-specific                              commands. Figure 1 shows a Command pattern class diagram.                              <!--#include virtual="/cgi-bin/pgnav.pl?cont=yes&pages=${pages}&${compare}"-->                           </p><!--#endif --><!--#if expr="${compare} = /^page\=2$/ || ${compare} = /^page\=full/" -->                           <p><img height="257" src="images/jw-06-designpatternsf1.jpg" width="446"></p>                           <p><strong>Figure 1. Command pattern class diagram</strong></p><!--#if expr="${compare} != /^page\=full/" --><!--#endif --><br><br>                            <p>In Figure 1, the <code>Invoker</code> class represents an object in an application framework, such as a button or menu item. The <code>Invoker</code> maintains an association with a command through a reference to an object that implements a <code>Command</code> interface, which defines an <code>execute()</code> method. Concrete command classes implement that interface, typically by using an object known as a <em>receiver</em>&#8212;application-specific objects that carry out the request. Figure 2 shows a Command pattern sequence diagram.                           </p>                           <p><img height="172" src="images/jw-06-designpatternsf2.jpg" width="491"></p>                           <p><strong>Figure 2. Command pattern sequence diagram</strong></p><br><br>                            <p>At runtime, the <code>Invoker</code> calls the <code>Command</code>'s <code>execute()</code> method, and the <code>Command</code> invokes a <code>Receiver</code>'s method&#8212;modeled here as an <code>action()</code> method&#8212;that carries out the request.                           </p>                           <h3>Swing actions</h3>                           <p>Almost all OO application frameworks implement the Command pattern, and Swing is no different. This section illustrates how                              Swing uses the Command pattern to perform application-specific functionality tied to Swing buttons serving as the building                              blocks for other components, such as menu items or toolbar buttons.                           </p>                           <p>Swing implements the Command pattern with <em>action</em> objects. Whenever you select a Swing menu item or activate a Swing button, those action objects issue a request to an application-specific                              action. Figure 3 shows a class diagram for Swing actions and how they relate to buttons and menus.                           </p>                           <center>                              <p><a alt="Figure 3. Swing actions class diagram. Click on thumbnail to view full-size image. " href="images/jw-06-designpatternsf3.jpg" target="new_window"><img height="403" src="images/jw-06-designpatternsf3-th.jpg" width="400"></a></p>                              <p><strong>Figure 3. Swing actions class diagram. Click on thumbnail to view full-size image.</strong></p>                           </center>                           <p>Buttons, defined by the <code>AbstractButton</code> class, serve as the Swing workhorses. For simplicity's sake, Figure 3's class diagram does not show all of the classes that                              ultimately extend <code>AbstractButton</code> because there are many <code>AbstractButton</code> ancestor classes. (<strong>Note:</strong> Figure 3 also omits most of the <code>AbstractButton</code> methods.) Swing buttons, radio buttons, toggle buttons, check boxes, menus, menu items, check-box menu items, and radio-button                              menu items are all <code>AbstractButton</code> class extensions. That class maintains a reference to an action defined by the <code>Action</code> interface. You can set or get that reference with the <code>AbstractAction</code> <code>setAction()</code> and <code>getAction()</code> methods, respectively.                           </p>                           <p>Whenever one of the aforementioned Swing components activates, it calls its action's <code>actionPerformed()</code> method, which implements some application-specific functionality. As a convenience, Swing's <code>AbstractAction</code> class eases the implemention of application-specific actions. Let's see how.                           </p>                           <p>Figure 4 shows a Swing application with a single menu featuring two menu items: "show dialog" and "exit." When you activate                              the "show dialog" menu item, as depicted in Figure 4's top picture, an application-specific action displays the dialog box                              shown in Figure 4's bottom picture. When you activate the "exit" menu item, another application-specific action terminates                              the application.                           </p>                           <p><img height="201" src="images/jw-06-designpatternsf4a.jpg" width="500"></p><br><br>                            <p><img height="201" src="images/jw-06-designpatternsf4b.jpg" width="500"></p>                           <p><strong>Figure 4. Swing actions in action</strong></p><br><br>                            <p>The application shown in Figure 4 is listed in Example 1:</p>                           <h3>Example 1. Two simple Swing actions</h3>                           <div id="codewrap">                              <div id="codewrap78"><pre>import java.awt.*;import java.awt.event.*;import javax.swing.*;public class Test extends JFrame {   public static void main(String args[]) {       Test frame = new Test();      frame.setTitle("Swing Actions");      frame.setSize(500, 400);      frame.setLocation(400, 200);      frame.show();   }   public Test() {      JMenuBar mb = new JMenuBar();      JMenu fileMenu = new JMenu("File"); <strong>    fileMenu.add(new ShowDialogAction());      fileMenu.add(new ExitAction());</strong>      mb.add(fileMenu);      setJMenuBar(mb);   }}<strong>class ShowDialogAction extends AbstractAction {</strong>   public ShowDialogAction() {      super("show dialog");   }   public void <strong>actionPerformed</strong>(ActionEvent e) {      JOptionPane.showMessageDialog((Component)e.getSource(),                               "An action generated this dialog");   }}<strong>class ExitAction extends AbstractAction {</strong>   public ExitAction() {      super("exit");   }   public void <strong>actionPerformed</strong>(ActionEvent e) {      System.exit(0);   }}</pre></div>                           </div><br><br>                            <p>The preceding application implements two actions&#8212;<code>ShowDialogAction</code> and <code>ExitAction</code>&#8212;both of which extend the <code>AbstractAction</code> class. Those classes implement their <code>actionPerformed()</code> methods to implement application-specific functionality; namely, showing a dialog and exiting the application, respectively.                              The application creates a file menu that's a <code>JMenu</code> class instance and passes instances of <code>ShowDialogAction</code> and <code>ExitAction</code> to that menu's <code>add()</code> method. The <code>add()</code> method creates a menu item&#8212;a <code>JMenuItem</code> instance&#8212;and associates the action it is passed with the newly created menu item by invoking the menu item's <code>add()</code> method, inherited from <code>AbstractAction</code>, as Figure 3 shows. From then on, the menu items and their actions are wired together: when the menu item is selected, it                              invokes its action's <code>actionPerformed()</code> method. That method is passed an action event, which provides information about the event, including the component that generated                              the event. The <code>ShowDialogAction.actionPerformed()</code> method uses that component to create a message dialog. (The <code>ExitAction.actionPerformed()</code> method has no use for the action event it is passed because it simply exits the application.)                              <!--#include virtual="/cgi-bin/pgnav.pl?cont=yes&pages=${pages}&${compare}"-->                           </p><!--#endif --><!--#if expr="${compare} = /^page\=3$/ || ${compare} = /^page\=full/" -->                           <p>The Swing Command pattern implementation closely adheres to the classic pattern's description in <em>Design Patterns</em>. In Swing, an <em>invoker</em> (in this case a menu item) maintains a reference to a <em>command</em> (in this case an action). That reference points to a command's abstract definition (the <code>AbstractAction</code> class), so that the command can represent any application-specific command (in this case a class that extends <code>AbstractAction</code>). When a trigger event occurs (in this case the menu item is selected), the invoker sends a request to the command and the                              command implements its application-specific functionality.                           </p>                           <p>Now that we've discussed a classic Command pattern implementation for client-side Java, let's take a look at another Command                              pattern implementation for server-side Java that deviates a bit from the classic Command pattern definition.                           </p><!--#if expr="${compare} != /^page\=full/" --><!--#endif -->                           <h3>Struts actions</h3>                           <p><a href="#resources">Struts</a>, a popular open source JSP application framework from the Apache Software Foundation, implements numerous design patterns,                              including the Model-View-Controller (MVC) pattern and, of course, the Command pattern. By applying design patterns to server-side                              Java components, such as servlets and JSPs, Struts makes it simple to implement modular, easily maintainable, and extensible                              Web applications.                           </p>                           <p>Struts comprises numerous pieces of distinct functionality, including JavaBean utilities, an XML digester, a database connection                              pool, and a comprehensive set of JSP custom tags. But the most significant cog in the Struts wheel is an MVC framework that                              revolves around the Command pattern. The rest of this article outlines that framework with a simple Web application.                           </p>                           <p>All Web applications, at their core, perform the same basic function: field HTTP requests and respond to those requests by                              performing some application-specific functionality. Struts provides a servlet&#8212;known as the <em>action servlet</em>&#8212;that handles HTTP requests and ultimately invokes an application-specific action. The Struts action servlet turns HTTP requests                              into actions, but as a developer employing Struts to implement Web applications, you can remain blissfully ignorant of how                              it works&#8212;that's the beauty of application frameworks and the Command pattern. You simply need to know how to map an HTTP request                              to a Struts action, how to implement that action, and you're off and running. Figure 5 shows a Struts-actions class diagram                              and how those actions relate to the action servlet.                           </p>                           <center>                              <p><a alt="Figure 5. Struts actions class diagram. Click on thumbnail to view full-size image. " href="images/jw-06-designpatternsf5.jpg" target="new_window"><img height="425" src="images/jw-06-designpatternsf5-th.jpg" width="400"></a></p>                              <p><strong>Figure 5. Struts actions class diagram. Click on thumbnail to view full-size image.</strong></p>                           </center>                           <p>Struts actions typically extend the <code>Action</code> class. Struts also provides <code>Action</code> subclasses you can extend for special-needs actions. For example, you can extend the <code>DispatchAction</code> class for actions that combine a set of similar actions in a single action class. In this article, I examine a simple action                              implementation that directly extends the <code>Action</code> class.                           </p>                           <p>Every Struts action maintains a reference to the action servlet, which is handy for accessing various servlet properties;                              for example, you can obtain a reference to your Web application with the action servlet's <code>getServletContext()</code> method. You can use that application to access application attributes, as you'll see shortly.                              <!--#include virtual="/cgi-bin/pgnav.pl?cont=yes&pages=${pages}&${compare}"-->                           </p><!--#endif --><!--#if expr="${compare} = /^page\=4$/ || ${compare} = /^page\=full/" -->                           <p>Now that you have a cursory understanding of Struts, let's dive in deeper by examining the simple Web application shown in                              Figure 6.                           </p>                           <p><img height="220" src="images/jw-06-designpatternsf6a.jpg" width="575"></p><!--#if expr="${compare} != /^page\=full/" --><!--#endif -->                           <p><img height="220" src="images/jw-06-designpatternsf6b.jpg" width="575"></p>                           <p><img height="220" src="images/jw-06-designpatternsf6c.jpg" width="575"></p>                           <p><strong>Figure 6. Use Struts actions</strong></p><br><br>                            <p>Figure 6's Web application consists of two JSPs: <code>test.jsp</code>, shown in the top picture and <code>forwardPage.jsp</code>, shown in the bottom two pictures. When you click on the link in <code>test.jsp</code>, an HTML anchor element sends an HTTP request to the Struts action servlet. The action servlet maps that request to an application-specific                              action that increments a counter stored in a file, and subsequently forwards to forwordPage.jsp. That JSP displays the counter's                              value and includes <code>test.jsp</code> so that you can initiate the request/action cycle again if you desire.                           </p>                           <p>To implement Figure 6's Web application, first configure the application in the deployment descriptor, as seen in Example                              2:                           </p>                           <h3>Example 2. WEB-INF/web.xml</h3>                           <div id="codewrap">                              <div id="codewrap146"><pre>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;&lt;!DOCTYPE web-app  PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.2//EN"  "http://java.sun.com/j2ee/dtds/web-app_2.2.dtd"&gt;&lt;web-app&gt;  &lt;!-- Action Servlet Configuration --&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;       <strong>action</strong>    &lt;/servlet-name&gt;    &lt;servlet-class&gt;      <strong>org.apache.struts.action.ActionServlet</strong>    &lt;/servlet-class&gt;    ...    &lt;init-param&gt;      &lt;param-name&gt;<strong>config</strong>&lt;/param-name&gt;      &lt;param-value&gt;<strong>/WEB-INF/action.xml</strong>&lt;/param-value&gt;    &lt;/init-param&gt;    ...  &lt;/servlet&gt;  &lt;!-- Action Servlet Mapping --&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;<strong>action</strong>&lt;/servlet-name&gt;    &lt;url-pattern&gt;<strong>*.do</strong>&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;  ...&lt;/web-app&gt;</pre></div>                           </div><br><br>                            <p>The preceding deployment descriptor does three things:</p>                           <ol>                              <li>Maps the name <strong>action</strong> to the Struts action servlet (<code>org.apache.struts.action.ActionServlet</code>)                              </li>                              <li>Creates an initialization parameter for the action servlet that specifies a Struts configuration file (<code>/WEB-INF/action.xml</code>)                              </li>                              <li>Maps all URLs that end in .do to the action servlet</li>                           </ol><br><br>                            <p>Example 3 lists <code>test.jsp</code>, the JSP shown in Figure 6's top picture:                           </p>                           <h3>Example 3. test.jsp</h3>                           <div id="codewrap">                              <div id="codewrap168"><pre>&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;&lt;html&gt;   &lt;head&gt;     &lt;title&gt;Struts Actions&lt;/title&gt;   &lt;/head&gt;   &lt;body&gt;     &lt;a href='simple.do'&gt;       Click Here to Perform a Simple Action     &lt;/a&gt;   &lt;/body&gt;&lt;/html&gt;</pre></div>                           </div><br><br>                            <p>The preceding JSP creates an HTML anchor element that references the <code>/simple.do</code> URL. If you click on that link, the Struts action servlet is invoked because the mapping in the deployment descriptor maps                              all URLs that end in .do to the action servlet (see Example 2). So what does the action servlet do when it receives the <code>/simple.do</code> URL? The answer resides in the Struts configuration file, which is specified in the deployment descriptor (see Example 2)                              and listed in Example 4:                           </p>                           <h3>Example 4. WEB-INF/action.xml</h3>                           <div id="codewrap">                              <div id="codewrap175"><pre>&lt;?xml version="1.0" encoding="ISO-8859-1" ?&gt;&lt;!DOCTYPE struts-config PUBLIC  "-//Apache Software Foundation//DTD Struts Configuration 1.0//EN"  "http://jakarta.apache.org/struts/dtds/struts-config_1_0.dtd"&gt;&lt;struts-config&gt;   &lt;action-mappings&gt;      &lt;action path="<strong>/simple</strong>"              type="<strong>actions.SimpleAction</strong>"&gt;         &lt;forward name="fwd-page" path="/forwardPage.jsp"/&gt;      &lt;/action&gt;   &lt;/action-mappings&gt;&lt;/struts-config&gt;</pre></div>                           </div><br><br>                            <p>The preceding configuration file maps the <code>/simple</code> URL to the <code>actions.SimpleAction</code> class. When the action servlet receives the <code>/simple.do</code> URL, it strips off the .do suffix and maps the URL to the <code>actions.SimpleAction</code> class. If an instance of that class does not exist, the <code>action</code> servlet creates one and invokes its <code>execute()</code> method. Example 5 lists the <code>actions.SimpleAction</code> class:                           </p>                           <h3>Example 5. WEB-INF/classes/actions/SimpleAction.java</h3>                           <div id="codewrap">                              <div id="codewrap189"><pre>package actions;import javax.servlet.ServletContext;import javax.servlet.http.*;import org.apache.struts.action.*;import beans.CounterBean;public class SimpleAction extends Action {     public ActionForward execute(ActionMapping mapping,                                 ActionForm form,                                HttpServletRequest request,                                 HttpServletResponse response)                  throws java.io.IOException,                          javax.servlet.ServletException {      ActionServlet      servlet = getServlet();      ServletContext application = servlet.getServletContext();      CounterBean    counterBean = (CounterBean)application.                                     getAttribute("counterBean");      if(counterBean == null) {         counterBean = new CounterBean();         application.setAttribute("counterBean", counterBean);      }      counterBean.updateCount(request, ".simpleActionCount");      return mapping.findForward("fwd-page");   } }</pre></div>                           </div><br><br>                            <p>The preceding action checks to see if a counter bean exists in the application scope; if not, it creates one and stores it                              there. Subsequently, the action invokes the counter bean's <code>updateCount()</code> method, which updates a counter stored in a file named <code>.simpleActionCount</code>. Then the action returns an <code>ActionForward</code> instance that points to a JSP mapped to the string <code>fwd-page</code>. That mapping, also defined in the Struts configuration file (see Example 4), resolves the string <code>fwd-page</code> to the <code>forwardPage.jsp</code> JSP. The <code>action</code> servlet subsequently forwards control to that JSP, listed in Example 6:                           </p>                           <h3>Example 6. forwardPage.jsp</h3>                           <div id="codewrap">                              <div id="codewrap201"><pre>&lt;%@ taglib uri='/WEB-INF/tlds/struts-bean.tld' prefix='struts'%&gt;&lt;%@ taglib uri='http://java.sun.com/jstl/core' prefix='c'%&gt;&lt;%@ page import='beans.CounterBean' %&gt;This simple action has been accessed &lt;c:out value='${counterBean.count}'/&gt; &lt;c:choose&gt;   &lt;c:when test='${counterBean.count == 1}'&gt;      time.   &lt;/c:when&gt;   &lt;c:otherwise&gt;      times.   &lt;/c:otherwise&gt;&lt;/c:choose&gt;&lt;p&gt;&lt;c:import url='test.jsp'/&gt;</pre></div>                           </div><br><br>                            <p>The preceding JSP uses the JSTL <code>&lt;c:out&gt;</code>, <code>&lt;c:choose&gt;</code>, <code>&lt;c:when&gt;</code>, and <code>&lt;c:otherwise&gt;</code> actions to display information about how many times the counter bean, and therefore the simple action, has been accessed.                              JSTL defines an expression language that will be incorporated into the upcoming JSP 2.0. The preceding JSP, for example, uses                              that expression language to access the counter bean in application scope. (You can download JSTL from <a href="#resources">Resources</a>.)                           </p>                           <p>Finally, Example 7 lists the counter bean class&#8212;<code>beans.CounterBean</code>:                           </p>                           <h3>Example 7. WEB-INF/classes/beans/CounterBean.java</h3>                           <div id="codewrap">                              <div id="codewrap213"><pre>package beans;import java.io.*;import javax.servlet.http.*;public class CounterBean {   private int count = 0;   private File file = null;   public synchronized void updateCount(HttpServletRequest request,                                        String filename)                                        throws java.io.IOException {      checkFile(filename);      readCount();      count++;      saveCount();   }   public int getCount() {      return count;   }   private void checkFile(String filename) throws IOException {      if(file == null) {         file  = new File(filename);         count = 0;      }      if(!file.exists()) {         file.createNewFile();         saveCount();      }   }   private void saveCount() throws java.io.IOException {      FileWriter writer = new FileWriter(file);      writer.write(count);      writer.close();   }   private void readCount() throws java.io.IOException {      FileReader reader = new FileReader(file);      count = reader.read();      reader.close();   }}</pre></div>                           </div><br><br>                            <p>The <code>CounterBean</code> class updates the count associated with a particular action. That class serves as a receiver, as I discussed at this article's                              beginning, by implementing application-specific behavior.                              <!--#include virtual="/cgi-bin/pgnav.pl?cont=yes&pages=${pages}&${compare}"-->                           </p><!--#endif --><!--#if expr="${compare} = /^page\=5$/ || ${compare} = /^page\=full/" -->                           <h3>Your wish is my command</h3>                           <p>Unless you develop application frameworks, you may never need to implement the Command pattern; nevertheless, you should understand                              how it works so you can effectively use application frameworks such as Swing and Struts. Now that you've seen how to use the                              Command pattern in Swing and Struts, you'll be able to better use those and other OO frameworks you encounter in the future.                           </p>                           <h3>Homework</h3>                           <p>For your homework assignment, download <a href="#resources">Struts</a>, then add your own custom action to the example discussed above. That custom action can implement whatever application-specific                              behavior you desire.                           </p><!--#if expr="${compare} != /^page\=full/" --><!--#endif -->                           <h3>Homework from last time</h3>                           <p>In your homework assignment from "<a href="/javaworld/jw-04-2002/jw-0426-designpatterns.html?">Strategy for Success</a>" (<em>JavaWorld,</em> April 2002), I asked you to discuss how Swing uses the Strategy pattern in its list class to render list cells.                           </p>                           <p>As "Strategy for Success" outlined, the Swing <code>JComponent</code> class uses the Strategy pattern to paint borders around components. The <code>JComponent</code> class also uses the Strategy pattern to paint Swing components themselves by delegating that behavior to individual Swing                              components; for example, the <code>JComponent.paint()</code> method invokes the <code>paintComponent()</code> method, which <code>JComponent</code> subclasses override to paint the component.                           </p>                           <p>Some Swing components, those with more complicated rendering needs, do not paint themselves; instead, they use the Strategy                              pattern to delegate that behavior to another object. For example, Swing lists delegate the painting of their list cells to                              an object that implements the <code>ListCellRenderer</code> interface. That interface defines a single method&#8212;<code>getListCellRendererComponent()</code>&#8212;that returns a component that paints the list's cells. That Strategy pattern usage lets developers modify how lists paint                              their cells by implementing a list cell renderer and attaching it to a specific list.                           </p>                           <h3>About the author</h3>David Geary is the                           author of Core JSTL Mastering the JSP Standard Tag                           Library, which will be published this fall by                           Prentice-Hall and Sun Microsystems Press; Advanced JavaServer Pages (Prentice                           Hall, 2001; ISBN: 0130307041); and the Graphic Java series (Sun Microsystems                           Press). David has been developing object-oriented software with                           numerous object-oriented languages for 18 years. Since the GOF                           Design Patterns book was published in 1994, David has been                           an active proponent of design patterns, and has used and                           implemented design patterns in Smalltalk, C++, and Java. In 1997,                           David began working full-time as an author and occasional speaker                           and consultant. David is a member of the expert groups defining the                           JSP standard custom tag library and JavaServer Faces, and is a                           contributor to the Apache Struts JSP framework.                           <p><a target="blank" href="http://www.javaworld.com/channel_content/jw-core-index.html">Read more about Core Java</a> in JavaWorld's Core Java section.                           </p><!--#endif --><!--#include virtual="/includes/global-pgnav.html" -->                                                      <p>
<font size="-1">All contents copyright 1995-2012 Java World, Inc. <a href='http://www.javaworld.com'>http://www.javaworld.com</a></font>
</body>
</html>
