<html><head><title>http://www.javaworld.com/javaworld/jw-06-1998/jw-06-undoredo.html</title>
</head>
<base href="http://www.javaworld.com/javaworld/jw-06-1998/jw-06-undoredo.html">
<body bgcolor="#FFFFFF">
<font size="1">Sponsored by:</font><BR>
<A HREF="http://ad.doubleclick.net/jump/idg.us.nwf.jw_core/jw_printer;pos=top;sz=728x90;tile=1;ord=1329851728?">
<IMG SRC="http://ad.doubleclick.net/ad/idg.us.nwf.jw_core/jw_printer;pos=top;sz=728x90;tile=1;ord=1329851728?" border=0 height="90" width="728"></A>
<p>
<IMG SRC="http://www.javaworld.com/includes/styles/i/javaworld-logo-wht-bg.gif" WIDTH="173" HEIGHT="57" ALT="From JavaWorld:"><br>
<BR>
<font size="-1">This story appeared on JavaWorld at<BR>
http://www.javaworld.com/javaworld/jw-06-1998/jw-06-undoredo.html<P></font>
                                                      <!--startindex-->                           <a id="top" name="top"></a><h1>Add an undo/redo function to your Java apps with Swing</h1>                           <H3>Find out how the Swing GUI component set utilizes the Command pattern for easy support of undo/redo</H3>                           <p class="byline">By&nbsp;Tomer Meshorer,&nbsp;JavaWorld.com,&nbsp;06/01/98</p>                           <!--#include virtual="/includes/community/storytools_bar_top.html"-->                                                      <!-- CONTENT GOES HERE-->                           <!--#set var="pages" value="7" --><!--#include virtual="/cgi-bin/pgnav05.pl?pageof=yes&pages=${pages}&${compare}" --><!--#if expr="${compare} = /^page\=1$/ || ${compare} = /^page\=full/" -->Not too long ago, Sun's Java division introduced the JFC, a comprehensive set of UI components and foundation services that                           give Java developers more flexibility to determine the look and feel of their applications. The UI component library, called                           Swing, is a whole lot more than a stripped-down set of lightweight UI components. Swing takes Java applications a step forward                           by allowing easy implementation of application services like undo -- the topic of our discussion today. <br><br>                            <p>Historically, application frameworks (for example, MacApp framework) have based the design of the undo/redo mechanism around                              the Command pattern. And that's what we're going to do as well. We'll discuss the Command pattern and describe how it supports                              the design of undo/redo systems. We'll then examine Java's support for the pattern and see how Swing's undo package adds the                              missing functionality, providing you with a complete undo/redo mechanism.                           </p>                           <h3>Requirements from an undo/redo mechanism</h3>                           <p>Undo allows users to correct their mistakes and also to try out different aspects of the application without risk of repercussions.</p>                           <p>At minimum, an undo/redo mechanism should provide users with the ability to:</p>                           <ul>                              <li>Unexecute (undo) the last action they just performed</li>                              <li>Re-execute (redo) the last undone action</li>                              <li>Undo and redo several recent actions (preferable, but optional)</li>                           </ul><br><br>                            <p>In order to design such a mechanism, we must treat the user's operations as individual <em>atomic</em> actions (self-contained actions that know how to undo/redo their effect on the application state) that should be stored for                              undo or redo later on. We can fulfill these requirements by using <em>design patterns</em>, specifically the Command pattern. If you are already familiar with the design patterns (specifically the Command pattern                              and how Java supports it), you can skip the next three sections and move right to "<a href="#undo">The undo/redo mechanism in Swing</a>."                           </p>                           <h3>Design patterns</h3>In a nutshell, design patterns encourage design reuse by providing established, successful design solutions for particular                           situations (also known as contexts). <br><br>                            <p>You may be wondering why I'm discussing design patterns in an article devoted to undo/redo mechanisms. It's really quite simple.                              In addition to presenting you with the technical implementation issues, I think it's important that you understand the design                              essentials of an undo/redo systems.                           </p>                           <p>According to <em>Design Patterns: Elements of Reusable Object-Oriented Software</em> by the now infamous Gang of Four (see <a href="#resources">Resources</a> for more information), the essential parts of any pattern are:                           </p>                           <ul>                              <li><em>Intent</em> -- The design goal that this pattern addresses                              </li>                              <li><em>Applicability</em> -- In what situation the pattern can be applied                              </li>                              <li><em>Structure</em> -- The design solution to the design problem                              </li>                              <li><em>Consequences</em> -- The trade-off of the solution                              </li>                           </ul><br><br>                            <p>A number of different patterns exist, but we're concerned only with the one that addresses undo/redo capabilities: the <em>Command pattern</em>.                           </p>                           <p><strong>The Command pattern</strong><br> Once again, according to <em>Design Patterns</em>, the purpose of the Command pattern is to:                           </p>                           <blockquote><em>Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests,                                 and</em> support undoable <em>operations.</em></blockquote><br><br>                            <p>Let's see how this works.                              <!--#include virtual="/cgi-bin/pgnav.pl?cont=yes&pages=${pages}&${compare}"-->                           </p><!--#endif --><!--#if expr="${compare} = /^page\=2$/ || ${compare} = /^page\=full/" -->                           <p>At the heart of the pattern is the <code>Command</code> interface, which defines the <code>execute()</code> method.                           </p>                           <div id="codewrap">                              <div id="codewrap49"><pre>001 public interface Command {002003    public void execute();004005 }</pre></div>                           </div><br><br>                            <p>All user actions (such as insert text, cut, paste; any operation that the user can perform) are encapsulated as <em>command objects</em>. A command object is a class that implements the function of performing the user's requested operation. For example, in a                              text editor when the user types in some text, we do not add this text directly to the document within the UI code; instead                              we create an <code>InsertTextCommand</code> object that we then apply to the text document.                           </p><!--#if expr="${compare} != /^page\=full/" --><!--#endif -->                           <p>All command objects must implement the <code>Command</code> interface. This interface declares an <code>execute()</code> method that should invoke the actual command operation on the target object. The following snippet shows a cut command for                              a text editor application.                           </p>                           <div id="codewrap">                              <div id="codewrap58"><pre>001 public class CutCommand implements Command{002003     private TextArea target_;004005     public CutCommand(TextArea area) {006          target_ = area;007     }008009     public execute() {010011 //       target_.cut();012          int startPos = target_.getSelectionStart();013          int endPos = target_.getSelectionEnd ();014          String text = target_.getText ();015          target_.setText (text.substring (0, startPos) + text.substring (endPos));016017     }018019 }</pre></div>                           </div><br><br>                            <p>When a <code>CutCommand</code> object is created, it's initialized with its target -- in this case, a text area. To build a text editor with cut capabilities,                              we attach this <code>CutCommand</code> to the editor's Cut menu item with the text area as its target. When the Cut menu item is selected, the <code>execute()</code> method of this command object is automatically invoked and the cut operation is performed as desired.                           </p>                           <p>From a design perspective, the important thing about the Command pattern is that it treats each user operation as a first-class                              object. If we add <code>unexecute()</code> and <code>reexecute()</code> methods to these objects (that is, to the <code>Command</code> interface), we can then support unexecution (undo) or re-execution (redo) of operations, giving us a basic undo/redo mechanism.                           </p>                           <p>Of course, adding undo and redo capabilities to this mechanism requires "smarter" commands. Not only should a command be able                              to invoke an operation on its target, but it should also be able to undo or redo that operation when prompted. For example,                              the cut command would store the selected string and location before the cut, allowing it to return the selection to the text                              area if its <code>undo()</code> method is invoked.                           </p>                           <p>Encapsulating each operation as a separate first-level object means that we can also easily support multilevel undo/redo operations:                              We store each command operation that the user performs in a <em>history list</em>. When the user selects undo, we perform the undo operation of the current item in the list and then step backwards to the                              previous item. To redo an operation, we execute the redo operation of the next item in the list and step forward. If the user                              performs a new command after some undo operations, we clear the front of the list to disable further redos.                              <!--#include virtual="/cgi-bin/pgnav.pl?cont=yes&pages=${pages}&${compare}"-->                           </p><!--#endif --><!--#if expr="${compare} = /^page\=3$/ || ${compare} = /^page\=full/" -->                           <p>However, because the Command pattern is attached to the menu item only at initialization, we must provide the means to duplicate                              commands and store them inside the history list. We can accomplish this using two different approaches:                           </p>                           <ul>                              <li><em>Use the Prototype pattern</em> -- Define the <code>clone ()</code> method for each command. After the command is executed, it is cloned and stored inside the history list.<br><br></li>                              <li><em>Separate the effect of the command from the actual execution</em> -- When the command is executed, it creates a new "effect" object, which stores the effect of the command. This object is                                 then stored in the history list.                              </li>                           </ul><br><br>                            <p>The Swing designers chose the latter approach.</p><!--#if expr="${compare} != /^page\=full/" --><!--#endif -->                           <p><strong>Java support for the Command pattern -- event listeners</strong><br> The closest support that Java provides for the Command pattern is the AWT delegation event model. Within this framework,                              command objects implement AWT listener interfaces instead of the <code>Command</code> interface. To associate a command object with an AWT component, we simply register it as an event listener. The component                              knows that the listener interface is there but it doesn't care how you implement it; that is, it doesn't care what the actual                              command operation is.                           </p>                           <p>For example, to support the cut operation we would provide an <code>ActionListener</code> that implements the <code>actionPerformed()</code> method (in place of <code>execute()</code>) to perform the cut operation, and would then register this with the Cut (<code>MenuItem</code> <code>addActionListener()</code>) method.                           </p>                           <p>Unfortunately, this system does not support the easy undo/redo facilities of the Command pattern. To support undo, each operation                              must result in a separate command object being instantiated. These objects can then maintain local state information about                              the effects of the operation they performed. Within the AWT model, however, just a single command object is attached to each                              operation and is repeatedly invoked for the user's actions.                           </p>                           <p>Enter Swing.</p>                           <h3><a id="undo" name="undo">The undo/redo mechanism in Swing</a></h3>                           <p>In Swing, the effect of a user action is stored separately from the listener implementation. Each effect is stored in an object                              that implements the <code>UndoableEdit</code> interface. As before, just a single command object (event listener) is instantiated and registered with an AWT component;                              however, each time this command object is invoked, a new <code>UndoableEdit</code> object is created to describe the effect of the operation. These effect objects take the place of the local state information                              in traditional command objects.                           </p>                           <p>The following is a Unified Modeling Language (UML) class diagram of Swing's undo mechanism. UML is an industry-standard language                              for specifying software systems; in this case, it is a useful standard for describing the classes of the Swing undo mechanism.                           </p>                           <center>                              <p><img height="600" src="undoredo/undoclassdiagram.gif" width="649"></p>                              <p><strong>Swing's undo mechanism class diagram</strong></p>                           </center>                           <p>Here's how it works.</p>                           <p>As I mentioned a moment ago, the effect of a user action is stored in an <code>UndoableEdit</code> object. For convenience, Swing includes an <code>AbstractUndoableEdit</code> class that provides default implementations of the various methods of this interface. So instead of directly implementing                              <code>UndoableEdit</code>, you can simply subclass <code>AbstractUndoableEdit</code> and only implement those methods that you require.                              <!--#include virtual="/cgi-bin/pgnav.pl?cont=yes&pages=${pages}&${compare}"-->                           </p><!--#endif --><!--#if expr="${compare} = /^page\=4$/ || ${compare} = /^page\=full/" -->                           <p>For every type of edit you want to support (an <em>edit</em> being the effect of a command that the user can invoke, such as inserting or cutting text), you must provide a subclass of                              <code>AbstractUndoableEdit</code> that encapsulates information about the effect of the command and provides facilities for undoing this effect. In essence,                              the concept of a command object has been replaced by a listener class that implements the command operation and an edit class                              that encapsulates information about the effect of each execution of this command.                           </p>                           <p>Sometimes, an edit will actually consist of a sequence of other, simpler edits (for example, a global-replace edit will be                              a sequence of individual replace edits). This type of edit can be captured by the <code>CompoundEdit</code> class. This class implements <code>UndoableEdit</code> and overrides the <code>undo()</code> method to invoke the <code>undo()</code> on each of its children in reverse order.                           </p><!--#if expr="${compare} != /^page\=full/" --><!--#endif -->                           <p>The next aspect of the Swing undo mechanism is the <em>undo listener</em>. Undo listeners are objects that implement the <code>UndoableEditListener</code> interface and are notified with <code>UndoableEditEvent</code> objects each time an undoable edit occurs. A special kind of listener is the <code>UndoManager</code>. When this listener is notified about an <code>UndoableEditEvent</code>, it extracts the edit from the event and stores it a queue. More about the <code>UndoManager</code> in a moment.                           </p>                           <p>An application that supports undoable edits must provide the <code>addUndoableEditListener()</code> and <code>removeUndoableEditListener()</code> methods that allow <code>UndoManager</code>s to be registered.                           </p>                           <p>Following the JavaBeans event model, Swing provides you with an <code>UndoableEditSupport</code> class to easily manage your listeners. You register your listeners with <code>addUndoableListener()</code> and deregister with <code>removeUndoableListener()</code>. To notify registered listeners of an edit, simply invoke the <code>postEdit()</code> method. This method automatically creates an <code>UndoableEditEvent</code> and passes it to each listener's <code>undoableEditHappened()</code> method. Additionally, this class provides simple support for performing compounds edits, allowing a sequence of simple edit                              operations to be automatically combined into a single <code>CompoundEdit</code>.                           </p>                           <p>Finally, Swing provides convenient support for adding a multilevel undo function to your application by supplying the <code>UndoManager</code> class, which implements <code>UndoableEditListener</code> and acts as a history list. The <code>UndoManager</code> class saves you from having to manually store all the edits performed by the user; it automatically stores these edits and                              provides pointers to the current undo and redo edits. Each time an undoable edit occurs (for example, a new element is added                              to a list) the <code>UndoManager</code> is notified, and the edit is added to its internal queue. You can set the queue limits by calling <code>setLimit()</code> on this manager.                           </p>                           <p>The following figure illustrates what happens inside the undo queue.</p>                           <center>                              <p><img height="400" src="undoredo/undoqueue.gif" width="401"></p>                              <p><strong>Inside the undo queue:<br> We start from an empty queue, add some actions, perform undo, and then perform another action.</strong></p>                           </center>                           <p>That's pretty much it. Now we can apply this foundation to a real example.</p>                           <h3>Hands on example</h3>                           <p>We're going to build a simple program to showcase Swing's undo/redo mechanism. Our applet, shown below, allows the user to                              add and remove elements to a <code>JList</code> component. When the user adds or removes an element, the applet stores the effect of that operation -- in either an <code>AddEdit</code> or <code>RemoveEdit</code> object -- for undo later.                              <!--#include virtual="/cgi-bin/pgnav.pl?cont=yes&pages=${pages}&${compare}"-->                           </p><!--#endif --><!--#if expr="${compare} = /^page\=5$/ || ${compare} = /^page\=full/" -->                           <p>Of course, to view and manipulate the applet, you must have Swing installed on your system. See <a href="#sidebar1" id="return1" name="return1">Installing Swing</a> for step-by-step instructions on the installation process.                           </p>                           <center><applet>CODEBASE = "." CODE = "undoapplet.LunchApplet.class" NAME = "TestApplet" WIDTH = "96" HEIGHT = "96" HSPACE = 0 VSPACE = 0&gt;                                 <strong>You need a Java-enabled browser to view this applet.</strong></applet></center><br><br>                            <p><em>Note: You must use a JDK 1.1-compliant browser to access this applet. Options include Netscape Communicator 4.0x with the                                 AWT 1.1 support patch, Netscape Communicator 4.05 pre-beta release for Windows 95/NT, and Appletviewer 1.1. (See <a href="#resources">Resources</a> for links to upgrade Communicator 4.0x and the latest version of Communicator).</em></p><!--#if expr="${compare} != /^page\=full/" --><!--#endif -->                           <p>Enough talk, let's code.</p>                           <p>The following classes comprise the example applet:</p>                           <ul>                              <li><a href="/javaworld/jw-06-1998/undoredo/LunchApplet.java"><code>LunchApplet</code></a> -- Starting point for the undo applet                              </li>                              <li><a href="/javaworld/jw-06-1998/undoredo/UndoPanel.java"><code>UndoPanel</code></a> -- The main program class                              </li>                              <li><a href="/javaworld/jw-06-1998/undoredo/AddEdit.java"><code>AddEdit</code></a> -- Captures the effect of adding elements to the list                              </li>                              <li><a href="/javaworld/jw-06-1998/undoredo/RemoveEdit.java"><code>RemoveEdit</code></a> -- Captures the effect of removing elements from the list                              </li>                              <li><a href="/javaworld/jw-06-1998/undoredo/UndoPanel.java"><code>AddAction</code></a> -- Inner class of <code>UndoPanel</code>; the add command                              </li>                              <li><a href="/javaworld/jw-06-1998/undoredo/UndoPanel.java"><code>RemoveAction</code></a> -- Inner class of <code>UndoPanel</code>; the remove command                              </li>                           </ul><br><br>                            <p>We'll begin with <code>AddEdit</code>.                           </p>                           <div id="codewrap">                              <div id="codewrap197"><pre>001 class AddEdit extends AbstractUndoableEdit {002003     private Object element_;004005     private int index_;006007     private DefaultListModel model_;008009     public AddEdit(DefaultListModel model, Object element, int index) {010          model_=model;011012          element_ = element;013014          index_=index;015     }016017     public void undo() throws CannotUndoException {018019         model_.removeElementAt(index_);020021     }022023     public void redo() throws CannotRedoException {024          model_.insertElementAt(element_,index_);025     }026027     public boolean canUndo() { return true; }028029     public boolean canRedo() { return true; }030031     public String getPresentationName() { return "Add"; }032034 }</pre></div>                           </div><br><br>                            <p>In the constructor (009-015) we store all the information needed to unexecute/re-execute an add action, including:</p>                           <ul>                              <li>The element that was added to the list</li>                              <li>The element index</li>                              <li>The list model itself (the receiver): The <code>DefaultListModel</code> class is a simple <code>Vector</code>-like interface to accessing the contents of a Swing <code>JList</code> component                              </li>                           </ul><br><br>                            <p>The <code>undo()</code> method (017-021) removes the element from the list, while <code>redo()</code> (023-025) inserts it back in. The <code>getPresentationName()</code> method, returns the name to be used for the undo and redo menu items. Note that if you inherit from <code>AbstractUndoableEdit</code>, Swing will handle the <code>getUndoPresentationName()</code> and <code>getRedoPresentationName()</code> return values by adding either "undo" or "redo" to the value returned from the <code>getPresentationName()</code> method.                           </p>                           <p>Now let's examine the add operation itself. The following segment defines the action object attached to the Add button. <code>Action</code> is a new Swing interface that makes the UI the central point of control. That is, an action can be added directly to a toolbar                              (resulting in a new button), or to a menu (resulting in a new menu item). When the action changes one of its properties (for                              example, becomes enabled or disabled), the UI elements are notified and change their state accordingly. For example, when                              <code>CutAction</code> becomes disabled, both the Cut toolbar button and the Cut menu item will be disabled as well. In any case, the <code>Action</code> interface encapsulates the <code>ActionListener</code> interface for handling <code>ActionEvent</code> events, and a description of the action itself.                              <!--#include virtual="/cgi-bin/pgnav.pl?cont=yes&pages=${pages}&${compare}"-->                           </p><!--#endif --><!--#if expr="${compare} = /^page\=6$/ || ${compare} = /^page\=full/" -->                           <p>When added to a container that supports <code>Action</code>, like <code>JToolBar</code> or <code>JMenu</code>, the <code>Action</code> item is queried to determine details of the component to be produced and is then automatically registered for UI events.                              The container registers the new component as a <code>PropertyListener</code> of the action.                           </p>                           <p><code>AbstractAction</code> is a concrete implementation of this interface that provides default implementations of all the new methods. In this case,                              however, we use only the listener aspect of <code>Action</code>.                           </p><!--#if expr="${compare} != /^page\=full/" --><!--#endif -->                           <div id="codewrap">                              <div id="codewrap233"><pre>001 private class AddAction extends AbstractAction {002003     public void actionPerformed(ActionEvent evt) {005         // always add to the end of the JList006         int NumOfElements = elementModel_.getSize();007         // however, give the element its ID number 008         Object element = new String("Foo " + _lastElementID);009         010         // record the effect011         UndoableEdit edit = new AddEdit(elementModel_,012                                    element, NumOfElements);013         // perform the operation014         elementModel_.addElement(element);015         016         // notify the listeners017         undoSupport_.postEdit(edit);017          018         // increment the ID019          _lastElementID ++ ;020021     }022023 }</pre></div>                           </div><br><br>                            <p>The <code>AddAction</code> class:                           </p>                           <ul>                              <li>Creates a new element (008)</li>                              <li>Creates a new <code>AddEdit</code> object and passes it the <code>ListModel</code> (the receiver of the action), the index of the new element, and the element itself (011)                              </li>                              <li>Performs the actual add operation (014)</li>                              <li>Notifies the undo listeners by calling <code>postEdit</code> on the <code>undoSupport objects</code> (017)                              </li>                           </ul><br><br>                            <p>Note that the <code>AddAction</code> class is a <em>private inner class</em> of our undo applet. This approach guarantees direct access to private members of the applet (for example, <code>undoSupport_</code>). Generally, I prefer to define actions as inner classes of the object that handles them, both to prevent bloated interfaces                              and to avoid breaking encapsulation (by exposing the object's internal structure -- for instance, where an external add action                              might want access to the <code>ListModel</code>).                           </p>                           <p><strong>UI consistency</strong><br> Of course, for a simple undo system, you will likely want to register the <code>UndoManager</code> as a sole listener to <code>UndoableEvent</code>s, providing an <code>UndoAction</code> that shows only a generic Undo label and invoking <code>undo()</code> on the manager.                           </p>                           <p>However, for a more sophisticated UI, you will want to provide the user with the last undoable operation. For instance, instead                              of just showing Undo you'll want to show Undo Cut.                           </p>                           <p>The following code snippet shows how to provide an <code>UndoAdaptor</code> class that updates the state of the undo components (in this case, Undo and Redo buttons) according to the new state of the                              undo history list.                           </p>                           <div id="codewrap">                              <div id="codewrap264"><pre>001 private class UndoAdaptor implements UndoableEditListener {002003     public void undoableEditHappened (UndoableEditEvent evt) {004005         UndoableEdit edit = evt.getEdit();006007         undoManager_.addEdit(edit);008009         refreshUndoRedo();010     }011 }</pre></div>                           </div><br><br>                            <p>The <code>UndoAdaptor</code> is registered in the <code>UndoableEditSupport</code> during the application setup. Each time an undo event occurs, the adaptor:                           </p>                           <ul>                              <li>Extracts the edit from the event (005)</li>                              <li>Adds it to the <code>UndoManager</code> (007)                              </li>                              <li>Refreshes the undo-related GUI state (009)</li>                           </ul><br><br>                            <p>An alternative approach would be to implement a subclass of <code>UndoManager</code> that overrides the <code>addEdit()</code> method to automatically refresh our user interface.                              <!--#include virtual="/cgi-bin/pgnav.pl?cont=yes&pages=${pages}&${compare}"-->                           </p><!--#endif --><!--#if expr="${compare} = /^page\=7$/ || ${compare} = /^page\=full/" -->                           <p>Here's the <code>refreshUndoRedo()</code> method.                           </p>                           <div id="codewrap">                              <div id="codewrap282"><pre>001 public void refreshUndoRedo() {002003     //refresh undo004005     undoBtn_.setText(undoManager_.getUndoPresentationName());006     undoBtn_.setEnabled(undoManager_.canUndo());007008     // refresh redo 009010     redoBtn_.setText(undoManager_.getRedoPresentationName());011     redoBtn_.setEnabled(undoManager_.canRedo()); 012013 } </pre></div>                           </div><br><br>                            <p>This method refreshes both the undo and the redo UI. The method retrieves the current edit information from the <code>undoManager</code>.                           </p><!--#if expr="${compare} != /^page\=full/" --><!--#endif -->                           <p><strong>The Undo action</strong><br> When the user presses the Undo button, the undo action is invoked, as shown next.                           </p>                           <div id="codewrap">                              <div id="codewrap290"><pre>001 private class UndoAction extends AbstractAction {002003     public void actionPerformed(ActionEvent evt ) {004005         undoManager_.undo();006007         refreshUndoRedo();008     }009 }</pre></div>                           </div><br><br>                            <p>All the complexity of managing the undo history list is handled by the <code>UndoManager</code> class. The undo operation simply invokes <code>undo()</code> on the manager and refreshes the applet GUI. We use the same code for the redo action, so I won't detail it here.                           </p>                           <p><strong>Wiring the parts together</strong><br> In the application constructor, we set up the system.                           </p>                           <div id="codewrap">                              <div id="codewrap299"><pre>001 public UndoPanel () {002    // construct the actions003    ActionListener undoAction = new undoAction();004    ActionListener redoAction = new redoAction();005   006    // register the listener007    undoBtn_ = new JButton("undo");008    undoBtn_.addActionListener(undoAction);009    redoBtn_ = new JButton("redo");010    redoBtn_.addActionListener(redoAction);011    012013    // initialize the undo.redo system014    undoManager_= new UndoManager();015    undoSupport_ = new UndoableEditSupport();016    undoSupport_.addUndoableEditListener(new UndoAdapter());017018 }</pre></div>                           </div><br><br>                            <h3>Conclusion</h3>                           <p>The Command pattern of encapsulating user actions in an application as individual first-class objects is extremely useful.                              It allows us to localize the implementation of undo/redo facilities to individual classes that themselves perform and undo                              the changes. This approach greatly eases maintenance; when we change a command operation, the undo/redo code is nearby and                              is completely independent of the undo/redo user interface code.                           </p>                           <p>Supporting undo/redo in your apps will provide your users with a sense of confidence as they learn how to manipulate the program.                              This article has shown you how easy it is to use Swing to implement such a feature. While it may be a small step for you as                              a developer, it is a huge step toward developing more complete and friendly applications.                           </p>                           <h3>About the author</h3>Tomer Meshorer is a framework architect at Comverse Network Systems in Tel                           Aviv, Israel. He develops Java-based object-oriented frameworks for                           visual programming IDEs. Tomer is a certified JDK 1.1 programmer                           and is devoted to design patterns, frameworks and, of course, Java.<!--#endif --><!--#include virtual="/includes/global-pgnav.html" -->                                                      <p>
<font size="-1">All contents copyright 1995-2012 Java World, Inc. <a href='http://www.javaworld.com'>http://www.javaworld.com</a></font>
</body>
</html>
