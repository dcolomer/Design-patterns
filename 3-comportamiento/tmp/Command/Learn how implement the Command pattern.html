<html><head><title>http://www.javaworld.com/javaworld/javatips/jw-javatip68.html</title>
</head>
<base href="http://www.javaworld.com/javaworld/javatips/jw-javatip68.html">
<body bgcolor="#FFFFFF">
<font size="1">Sponsored by:</font><BR>
<A HREF="http://ad.doubleclick.net/jump/idg.us.nwf.jw_core/jw_printer;pos=top;sz=728x90;tile=1;ord=1329851582?">
<IMG SRC="http://ad.doubleclick.net/ad/idg.us.nwf.jw_core/jw_printer;pos=top;sz=728x90;tile=1;ord=1329851582?" border=0 height="90" width="728"></A>
<p>
<IMG SRC="http://www.javaworld.com/includes/styles/i/javaworld-logo-wht-bg.gif" WIDTH="173" HEIGHT="57" ALT="From JavaWorld:"><br>
<BR>
<font size="-1">This story appeared on JavaWorld at<BR>
http://www.javaworld.com/javaworld/javatips/jw-javatip68.html<P></font>
                                                      <!--startindex-->                           <a id="top" name="top"></a><h1>Java Tip 68: Learn how to implement the Command pattern in Java</h1>                           <H3>Add flexibility and extensibility to your programs with this object-oriented equivalent of the callback</H3>                           <p class="byline">By&nbsp;Bala Paranj,&nbsp;JavaWorld.com,&nbsp;02/01/99</p>                           <!--#include virtual="/includes/community/storytools_bar_top.html"-->                                                      <!-- CONTENT GOES HERE-->                           <!--#set var="pages" value="4" --><!--#include virtual="/cgi-bin/pgnav05.pl?pageof=yes&pages=${pages}&${compare}" --><!--#if expr="${compare} = /^page\=1$/ || ${compare} = /^page\=full/" -->Design patterns not only accelerate the design phase of an object-oriented (OO) project but also increase the productivity                           of the development team and quality of the software. A <em>Command pattern</em> is an object behavioral pattern that allows us to achieve complete decoupling between the sender and the receiver. (A <em>sender</em> is an object that invokes an operation, and a <em>receiver</em> is an object that receives the request to execute a certain operation. With <em>decoupling,</em> the sender has no knowledge of the <code>Receiver</code>'s interface.) The term <em>request</em> here refers to the command that is to be executed. The Command pattern also allows us to vary when and how a request is fulfilled.                           Therefore, a Command pattern provides us flexibility as well as extensibility.<br><br>                            <p>In programming languages like C, <em>function pointers</em> are used to eliminate giant switch statements. (See "<a href="/javaworld/javatips/jw-javatip30.html">Java Tip 30: Polymorphism and Java</a>" for a more detailed description.) Since Java doesn't have function pointers, we can use the Command pattern to implement                              callbacks. You'll see this in action in the first code example below, called <code>TestCommand.java</code>.                           </p>                           <p>Developers accustomed to using function pointers in another language might be tempted to use the <code>Method</code> objects of the Reflection API in the same way. For example, in his article "Java Reflection," Paul Tremblett shows you how                              to use Reflection to implement transactions without using switch statements. I've resisted this temptation, since Sun advises                              against using the Reflection API when other tools more natural to the Java programming language will suffice. (See <a href="#resources">Resources</a> for links to Tremblett's article and for Sun's Reflection tutorial page.) Your program will be easier to debug and maintain                              if you don't use <code>Method</code> objects. Instead, you should define an interface and implement it in the classes that perform the needed action.                           </p>                           <p>Therefore, I suggest you use the Command pattern combined with Java's dynamic loading and binding mechanism to implement function                              pointers. (For details on Java's dynamic loading and binding mechanism, see James Gosling and Henry McGilton's "The Java Language                              Environment -- A White Paper," listed in <a href="#resources">Resources</a>.)                           </p>                           <p>By following the above suggestion, we exploit the polymorphism provided by the application of a Command pattern to eliminate                              giant switch statements, resulting in extensible systems. We also exploit Java's unique dynamic loading and binding mechanisms                              to build a dynamic and dynamically extensible system. This is illustrated in the second code sample example below, called                              <code>TestTransactionCommand.java</code>.                           </p>                           <p>The Command pattern turns the request itself into an object. This object can be stored and passed around like other objects.                              The key to this pattern is a <code>Command</code> interface, which declares an interface for executing operations. In its simplest form, this interface includes an abstract                              <code>execute</code> operation. Each concrete <code>Command</code> class specifies a receiver-action pair by storing the <code>Receiver</code> as an instance variable. It provides different implementations of the <code>execute()</code> method to invoke the request. The <code>Receiver</code> has the knowledge required to carry out the request.                              <!--#include virtual="/cgi-bin/pgnav.pl?cont=yes&pages=${pages}&${compare}"-->                           </p><!--#endif --><!--#if expr="${compare} = /^page\=2$/ || ${compare} = /^page\=full/" -->                           <p>Figure 1 below shows the <code>Switch</code> -- an aggregation of <code>Command</code> objects. It has <code>flipUp()</code> and <code>flipDown()</code> operations in its interface. <code>Switch</code> is called the <em>invoker</em> because it invokes the execute operation in the command interface.                           </p>                           <p>The concrete command, <code>LightOnCommand</code>, implements the <code>execute</code> operation of the command interface. It has the knowledge to call the appropriate <code>Receiver</code> object's operation. It acts as an adapter in this case. By the term <em>adapter,</em> I mean that the concrete <code>Command</code> object is a simple connector, connecting the <code>Invoker</code> and the <code>Receiver</code> with different interfaces.                           </p><!--#if expr="${compare} != /^page\=full/" --><!--#endif -->                           <p>The client instantiates the <code>Invoker</code>, the <code>Receiver</code>, and the concrete command objects.                           </p>                           <center>                              <p><img height="192" src="images/structure.gif" width="425"></p>                           </center>                           <p>Figure 2, the sequence diagram, shows the interactions between the objects. It illustrates how <code>Command</code> decouples the <code>Invoker</code> from the <code>Receiver</code> (and the request it carries out). The client creates a concrete command by parameterizing its constructor with the appropriate                              <code>Receiver</code>. Then it stores the <code>Command</code> in the <code>Invoker</code>. The <code>Invoker</code> calls back the concrete command, which has the knowledge to perform the desired <code>Action()</code> operation.                           </p>                           <center>                              <p><img height="206" src="images/sequence.gif" width="386"></p>                           </center>                           <p>The client (main program in the listing) creates a concrete <code>Command</code> object and sets its <code>Receiver</code>. As an <code>Invoker</code> object, <code>Switch</code> stores the concrete <code>Command</code> object. The <code>Invoker</code> issues a request by calling <code>execute</code> on the <code>Command</code> object. The concrete <code>Command</code> object invokes operations on its <code>Receiver</code> to carry out the request.                              <!--#include virtual="/cgi-bin/pgnav.pl?cont=yes&pages=${pages}&${compare}"-->                           </p><!--#endif --><!--#if expr="${compare} = /^page\=3$/ || ${compare} = /^page\=full/" -->                           <p>The key idea here is that the concrete command registers itself with the <code>Invoker</code> and the <code>Invoker</code> calls it back, executing the command on the <code>Receiver</code>.                           </p>                           <h3>Command pattern example code</h3>                           <p>Let's take a look at a simple example illustrating the callback mechanism achieved via the Command pattern.</p><!--#if expr="${compare} != /^page\=full/" --><!--#endif -->                           <p>The example shows a <code>Fan</code> and a <code>Light</code>. Our objective is to develop a <code>Switch</code> that can turn either object on or off. We see that the <code>Fan</code> and the <code>Light</code> have different interfaces, which means the <code>Switch</code> has to be independent of the <code>Receiver</code> interface or it has no knowledge of the code&gt;Receiver's interface. To solve this problem, we need to parameterize each of                              the <code>Switch</code>s with the appropriate command. Obviously, the <code>Switch</code> connected to the <code>Light</code> will have a different command than the <code>Switch</code> connected to the <code>Fan</code>. The <code>Command</code> class has to be abstract or an interface for this to work.                           </p>                           <p>When the constructor for a <code>Switch</code> is invoked, it is parameterized with the appropriate set of commands. The commands will be stored as private variables of                              the <code>Switch</code>.                           </p>                           <p>When the <code>flipUp()</code> and <code>flipDown()</code> operations are called, they will simply make the appropriate command to <code>execute( )</code>. The <code>Switch</code> will have no idea what happens as a result of <code>execute( )</code> being called.                           </p>                           <div id="codewrap">                              <div id="codewrap100"><pre>TestCommand.javaclass Fan {        public void startRotate() {                System.out.println("Fan is rotating");        }        public void stopRotate() {                System.out.println("Fan is not rotating");        }}class Light {        public void turnOn( ) {                System.out.println("Light is on ");        }        public void turnOff( ) {                System.out.println("Light is off");        }}class Switch {        private Command UpCommand, DownCommand;        public Switch( Command Up, Command Down) {                UpCommand = Up; // concrete Command registers itself with the invoker                 DownCommand = Down;        }        void flipUp( ) { // invoker calls back concrete Command, which executes the Command on the receiver                         UpCommand . execute ( ) ;                                   }        void flipDown( ) {                        DownCommand . execute ( );        }}class LightOnCommand implements Command {        private Light myLight;        public LightOnCommand ( Light L) {                myLight  =  L;        }        public void execute( ) {                myLight . turnOn( );        }}class LightOffCommand implements Command {        private Light myLight;        public LightOffCommand ( Light L) {                myLight  =  L;        }        public void execute( ) {                myLight . turnOff( );        }}class FanOnCommand implements Command {        private Fan myFan;        public FanOnCommand ( Fan F) {                myFan  =  F;        }        public void execute( ) {                myFan . startRotate( );        }}class FanOffCommand implements Command {        private Fan myFan;        public FanOffCommand ( Fan F) {                myFan  =  F;        }        public void execute( ) {                myFan . stopRotate( );        }}public class TestCommand {                public static void main(String[] args) {                        Light  testLight = new Light( );                        LightOnCommand testLOC = new LightOnCommand(testLight);                        LightOffCommand testLFC = new LightOffCommand(testLight);                        Switch testSwitch = new Switch( testLOC,testLFC);                               testSwitch.flipUp( );                        testSwitch.flipDown( );                        Fan testFan = new Fan( );                        FanOnCommand foc = new FanOnCommand(testFan);                        FanOffCommand ffc = new FanOffCommand(testFan);                        Switch ts = new Switch( foc,ffc);                        ts.flipUp( );                        ts.flipDown( );                 }}               Command.javapublic interface Command {        public abstract void execute ( );}</pre></div>                           </div><br><br>                            <p>Notice in the code example above that the Command pattern completely decouples the object that invokes the operation -- <code>(Switch )</code> -- from the ones having the knowledge to perform it -- <code>Light</code> and <code>Fan</code>. This gives us a lot of flexibility: the object issuing a request must know only how to issue it; it doesn't need to know                              how the request will be carried out.                              <!--#include virtual="/cgi-bin/pgnav.pl?cont=yes&pages=${pages}&${compare}"-->                           </p><!--#endif --><!--#if expr="${compare} = /^page\=4$/ || ${compare} = /^page\=full/" -->                           <h3>Command pattern to implement transactions</h3>                           <p>A Command pattern is also known as an <em>action</em> or <em>transaction pattern.</em> Let us consider a server that accepts and processes transactions delivered by clients via a TCP/IP socket connection. These                              transactions consist of a command, followed by zero or more arguments.                           </p>                           <p>Developers might use a switch statement with a case for each command. Usage of <code>Switch</code> statements during coding is a sign of bad design during the design phase of an object-oriented project. Commands represent                              an object-oriented way to support transactions and can be used to solve this design problem.                           </p><!--#if expr="${compare} != /^page\=full/" --><!--#endif -->                           <p>In the client code of the program <code>TestTransactionCommand.java</code>, all the requests are encapsulated into the generic <code>TransactionCommand</code> object. The <code>TransactionCommand</code> constructor is created by the client and it is registered with the <code>CommandManager</code>. The queued requests can be executed at different times by calling the <code>runCommands()</code>, which gives us a lot of flexibility. It also gives us the ability to assemble commands into a composite command. I also                              have <code>CommandArgument</code>, <code>CommandReceiver</code>, and <code>CommandManager</code> classes and subclasses of <code>TransactionCommand</code> -- namely <code>AddCommand</code> and <code>SubtractCommand</code>. Following is a description of each of these classes:                           </p>                           <ul>                              <li><code>CommandArgument</code> is a helper class, which stores the arguments of the command. It can be rewritten to simplify the task of passing a large                                 or variable number of arguments of any type.<br><br></li>                              <li><code>CommandReceiver</code> implements all the command-processing methods and is implemented as a Singleton pattern.<br><br></li>                              <li><code>CommandManager</code> is the invoker and is the <code>Switch</code> equivalent from the previous example. It stores the generic <code>TransactionCommand</code> object in its private <code>myCommand</code> variable. When <code>runCommands( )</code> is invoked, it calls the <code>execute( )</code> of the appropriate <code>TransactionCommand</code> object.                              </li>                           </ul><br><br>                            <p>In Java, it is possible to look up the definition of a class given a string containing its name. In the <code>execute ( )</code> operation of the <code>TransactionCommand</code> class, I compute the class name and dynamically link it into the running system -- that is, classes are loaded on the fly                              as required. I use the naming convention, command name concatenated by the string "Command" as the name of the transaction                              command subclass, so that it can be loaded dynamically.                           </p>                           <p>Notice that the <code>Class</code> object returned by the <code>newInstance( )</code> has to be cast to the appropriate type. This means the new class has to either implement an interface or subclass an existing                              class which is known to the program at compile time. In this case, since we implement the <code>Command</code> interface, this isn't a problem.                           </p>                           <div id="codewrap">                              <div id="codewrap151"><pre>//TestTransactionCommand.javaimport java.util.*;final class CommandReceiver {  private int[] c;  private CommandArgument a;     private CommandReceiver(){       c = new int[2];     }     private static CommandReceiver cr = new CommandReceiver();     public static CommandReceiver getHandle() {     return cr;     }     public void setCommandArgument(CommandArgument a) {     this.a = a;     }     public void methAdd() {     c = a.getArguments();         System.out.println("The result is " + (c[0]+c[1]));     }     public void methSubtract() {     c = a.getArguments();         System.out.println("The result is " + (c[0]-c[1]));     }} class CommandManager {   private Command myCommand;   public CommandManager(Command  myCommand) {     this.myCommand  =  myCommand ;       }   public void runCommands( ) {            myCommand.execute();        } }class TransactionCommand implements Command {  private CommandReceiver commandreceiver;  private Vector commandnamelist,commandargumentlist;   private String commandname;  private CommandArgument commandargument;  private Command command;  public TransactionCommand () {    this(null,null);  }  public TransactionCommand ( Vector  commandnamelist, Vectorcommandargumentlist){    this.commandnamelist = commandnamelist;    this.commandargumentlist = commandargumentlist;    commandreceiver =  CommandReceiver.getHandle();    }  public void execute( ) {    for (int i = 0; i &lt; commandnamelist.size(); i++) {      commandname = (String)(commandnamelist.get(i));      commandargument = (CommandArgument)((commandargumentlist.get(i)));      commandreceiver.setCommandArgument(commandargument);      String classname = commandname + "Command";         try {           Class cls = Class.forName(classname);           command = (Command) cls.newInstance();         }         catch (Throwable e) {                     System.err.println(e);         }      command.execute();    }   }} class AddCommand extends TransactionCommand {   private CommandReceiver cr;   public AddCommand () {      cr = CommandReceiver.getHandle();     }     public void execute( ) {       cr.methAdd();     }    } class SubtractCommand extends TransactionCommand {   private CommandReceiver cr;   public SubtractCommand () {      cr = CommandReceiver.getHandle();     }   public void execute( ) {     cr.methSubtract();   }    } class CommandArgument {   private int[] args;   CommandArgument() {     args = new int[2];   }   public int[] getArguments() {    return args;   }   public void setArgument(int i1, int i2) {         args[0] = i1; args[1] = i2;   } } public class TestTransactionCommand {   private  Vector clist,alist;    public TestTransactionCommand() {     clist = new Vector();        alist = new Vector();   }   public void clearBuffer(Vector c, Vector a) {     clist.removeAll(c);       alist.removeAll(a);    }   public Vector getClist() {     return clist;   }   public Vector getAlist() {     return alist;   }    public static void main(String[] args) {       CommandArgument ca,ca2;     TestTransactionCommand t = new TestTransactionCommand();     ca = new CommandArgument();     ca.setArgument(2,8);     Vector myclist = t.getClist();     Vector myalist = t.getAlist();     myclist.addElement("Add"); myalist.addElement(ca);     TransactionCommand tc = new TransactionCommand(myclist,myalist);     CommandManager cm = new CommandManager(tc);                           cm.runCommands();     t.clearBuffer(myclist,myalist);     ca2 = new CommandArgument();     ca2.setArgument(5,7);     myclist = t.getClist();     myalist = t.getAlist();     myclist.addElement("Subtract"); myalist.addElement(ca2);     myclist.addElement("Add"); myalist.addElement(ca2);     TransactionCommand tc2 = new TransactionCommand(myclist,myalist);             CommandManager cm2 = new CommandManager(tc2);                           cm2.runCommands();   } }               </pre></div>                           </div><br><br>                            <p>The command and its arguments are stored in a list and encapsulated into the generic <code>TransactionCommand</code> object. The generic <code>TransactionCommand</code> is registered with the <code>CommandManager</code>. The commands can be run at any time by invoking the <code>runCommands()</code> interface in the <code>CommandManager</code> class.                           </p>                           <p>The client code doesn't depend on any of the concrete <code>TransactionCommand</code> subclasses, which means I have programmed to the interface and not the implementation. This gives us extensibility: to add                              a new command, we need to define a new <code>TransactionCommand</code> subclass and provide the implementation for the new command-processing method in the <code>CommandReceiver</code> class. That's all there is to it.                           </p>                           <h3>Conclusion</h3>                           <p>The Command pattern has the following advantages:</p>                           <ol>                              <li>A command decouples the object that invokes the operation from the one that knows how to perform it.<br><br></li>                              <li>A command is a first-class object. It can be manipulated and extended like any other object.<br><br></li>                              <li>Commands can be assembled into a composite command.<br><br></li>                              <li>It's easy to add new commands, because you don't have to change the existing classes.</li>                           </ol><br><br>                            <p>When the sequence of commands executed is saved in a history list, you can iterate through the list to support undo and redo                              operations. You must have an <code>unexecute()</code> operation in the <code>Command</code> interface to implement this functionality. I will leave this as an exercise for the reader.                           </p>                           <p><em>Some of this material was inspired by class notes from an object-oriented design class given by William E. Fairfield at the                                 University of California Santa Cruz Extension.</em></p>                           <h3>About the author</h3>Bala Paranj is a corporate applications                           engineer at Mentor Graphics, Microtec Division. There he resolves                           complex technical problems of real-time operating systems,                           including test case generation, and research and evaluation of                           potential solutions. He has a Master of Science degree in                           Electrical Engineering from The Wichita State University, Wichita,                           Kansas. His research interests include applying design patterns to                           solve networking problems, concurrent programming, and                           implementation of the solution in Java. When he's not programming,                           he enjoys dancing, volleyball, chess, and spending time in nature.                           <p><a target="blank" href="http://www.javaworld.com/channel_content/jw-core-index.html">Read more about Core Java</a> in JavaWorld's Core Java section.                           </p><!--#endif --><!--#include virtual="/includes/global-pgnav.html" -->                                                      <p>
<font size="-1">All contents copyright 1995-2012 Java World, Inc. <a href='http://www.javaworld.com'>http://www.javaworld.com</a></font>
</body>
</html>
